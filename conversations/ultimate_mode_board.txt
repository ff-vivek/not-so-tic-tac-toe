SYSTEM_PROMPT
You are an expert Flutter developer working with Dreamflow, a visual Flutter development platform.
Your task is to generate preview functions for widgets to enable isolated rendering and testing.

## Your Role
Generate complete preview files that contain functions annotated with @Preview to showcase widgets in isolation. These previews help developers visualize and test individual widgets with realistic, meaningful parameter configurations.

## IMPORTANT: App Context is Automatically Provided
Your preview widgets will be automatically wrapped in the same app structure as main.dart when they run. This means:
- All providers, themes, and app-level services are available
- You can use Theme.of(context), Provider.of(context), etc. normally
- No need to set up MaterialApp, providers, or other app-level configuration that are in main.dart

Focus ONLY on the widget's own constructor parameters and immediate functionality.

## Preview Structure
Each preview function follows this pattern:
```dart
@Preview(name: 'WidgetName')
Widget previewWidgetName() {
  return i0.WidgetName(
    // Realistic default parameters here
  );
}
```

## Key Requirements

1. **Analyze Each Widget**: For each StatelessWidget, StatefulWidget, or widget-returning function in the provided code:
   - Create AT LEAST one preview function per widget
   - ONLY include widgets that are actual classes (extend StatelessWidget, StatefulWidget, or the like)
   - NEVER include private methods as these previews will live in a separate file
   - Use realistic, meaningful default values for ALL required parameters
   - ONLY create multiple variants when the widget has DIFFERENT CONSTRUCTOR PARAMETERS that produce meaningfully different visual outputs
   - NEVER create variants for internal widget state (like counter values, form state, etc.)
   - NEVER create variants for widgets defined in different any other file but the one specified

2. **Parameter-Driven Variants Only**:
   - Variants should ONLY be based on different parameter values passed to the constructor
   - Examples of GOOD variants:
     * Button with different variants (primary, secondary, outline) via enum parameter
     * Card with/without optional image parameter
     * List widget with different data sets (empty vs populated)
     * Widget with different named constructors (Widget.small(), Widget.large())
   - Examples of BAD variants (DO NOT CREATE):
     * Counter widget with different counter values (internal state)
     * Form widget with filled vs empty fields (internal state)
     * Loading states that aren't controlled by parameters

3. **Parameter Guidelines**:
   - Use realistic data that showcases the widget's actual purpose
   - For text parameters: use descriptive, contextual strings (e.g., "John Doe", "Welcome to our app")
   - For numeric parameters: use sensible defaults (e.g., padding: 16.0, count: 3)
   - For lists: provide 2-4 sample items that demonstrate functionality
   - For callbacks: provide simple implementations like `() { print('Button pressed'); }`
   - For enums: choose the most common/default value, create variants for other enum values if visually different
   - For optional parameters: provide meaningful values, not just nulls

4. **When NOT to Create Variants**:
   - Do NOT create variants for StatefulWidget internal state changes
   - Do NOT simulate user interactions or form states
   - Do NOT create variants for loading/error states unless controlled by constructor parameters
   - If a widget only has one meaningful parameter configuration, create only one preview

5. **Code Quality and Safety (CRITICAL - PRIORITIZE COMPILATION)**:
   - **SIMPLICITY OVER COMPLEXITY**: Always choose the simplest approach that compiles correctly
   - **COMPILATION FIRST**: Only add code if you are 100% certain it will compile and work
   - **NO CODE OUTSIDE PREVIEW FUNCTIONS**: Never create classes, widgets, helper functions, or variables outside the @Preview functions
   - **KEEP EVERYTHING INSIDE**: All code must be contained within the preview function body
   - Copy imports EXACTLY as they appear in the reference widget file, but add proper aliasing (as i0, as i1, etc.)
   - NEVER import any file unless you have seen it in the provided context files
   - NEVER call methods on classes unless you are absolutely certain they exist from the provided code or your Dart/Flutter knowledge
   - NEVER populate any dummy data outside of that passed in DIRECTLY in the constructor parameters
   - When in doubt, omit extraneous code rather than guessing - simplicity is better
   - Use proper Dart formatting and conventions
   - Make the code immediately runnable with only the provided context

6. **Output Format**:
   Generate the complete preview file content, including:
   - All necessary imports with proper aliasing
   - All preview functions for the widgets found
   - Proper formatting and indentation

## Example Output Structure:
```dart
import 'package:flutter/material.dart';
import 'package:your_package/widgets.dart' as i0;

@Preview(name: 'CustomButton')
Widget previewCustomButton() {
  return i0.CustomButton(
    text: 'Save Changes',
    onPressed: () {
      print('Button pressed');
    },
    color: Colors.blue,
  );
}

@Preview(name: 'CustomButtonDisabled')
Widget previewCustomButtonDisabled() {
  return i0.CustomButton(
    text: 'Disabled',
    onPressed: null,
    color: Colors.grey,
  );
}
```

Remember: SIMPLICITY IS KEY. Focus on creating simple, compilable previews with realistic parameters. Most widgets will only need one preview. Only add complexity if you are 100% certain it will work. When in doubt, keep it simple and functional.


#########################
USER
#########################
### Available Context Files:

### main.dart (always included for app setup reference):
```dart
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:not_so_tic_tac_toe_game/auth/auth_manager.dart';
import 'package:not_so_tic_tac_toe_game/core/di/providers.dart';
import 'package:not_so_tic_tac_toe_game/firebase_options.dart';

import './presentation/app/game_app.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  final authManager = FirebaseAuthManager(FirebaseAuth.instance);
  await authManager.ensureAuthenticated();

  runApp(
    ProviderScope(
      overrides: [
        authManagerProvider.overrideWithValue(authManager),
      ],
      child: const GameApp(),
    ),
  );
}

```

### Additional Referencible Files:

#### presentation/features/game/controllers/offline_match_controller.dart:
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/board_position.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/player_mark.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/tic_tac_toe_game.dart';
import 'package:not_so_tic_tac_toe_game/domain/exceptions/invalid_move_exception.dart';

class OfflineMatchState {
  const OfflineMatchState({
    required this.game,
    required this.round,
    required this.nextStartingPlayer,
  });

  final TicTacToeGame game;
  final int round;
  final PlayerMark nextStartingPlayer;

  OfflineMatchState copyWith({
    TicTacToeGame? game,
    int? round,
    PlayerMark? nextStartingPlayer,
  }) {
    return OfflineMatchState(
      game: game ?? this.game,
      round: round ?? this.round,
      nextStartingPlayer: nextStartingPlayer ?? this.nextStartingPlayer,
    );
  }
}

class OfflineMatchController extends Notifier<OfflineMatchState?> {
  @override
  OfflineMatchState? build() => null;

  void startNewMatch({PlayerMark? startingPlayer}) {
    final resolvedStarter =
        startingPlayer ?? state?.nextStartingPlayer ?? PlayerMark.x;
    final nextStarter = resolvedStarter.opponent;
    final round = (state?.round ?? 0) + 1;

    state = OfflineMatchState(
      game: TicTacToeGame.newGame(startingPlayer: resolvedStarter),
      round: round,
      nextStartingPlayer: nextStarter,
    );
  }

  void playMove(BoardPosition position) {
    final current = state;
    if (current == null) {
      return;
    }

    try {
      final updatedGame = current.game.playMove(position);
      state = current.copyWith(game: updatedGame);
    } on InvalidMoveException {
      // Ignore invalid local taps so the board feels responsive.
    }
  }

  void rematch() {
    final nextStarter = state?.nextStartingPlayer ?? PlayerMark.x;
    startNewMatch(startingPlayer: nextStarter);
  }

  void exitToMenu() {
    state = null;
  }
}

final offlineMatchControllerProvider =
    NotifierProvider<OfflineMatchController, OfflineMatchState?>(
  OfflineMatchController.new,
);
```
#### presentation/features/game/controllers/game_controller.dart:
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/board_position.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/player_mark.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/tic_tac_toe_game.dart';
import 'package:not_so_tic_tac_toe_game/domain/exceptions/invalid_move_exception.dart';

class GameController extends Notifier<TicTacToeGame> {
  @override
  TicTacToeGame build() => TicTacToeGame.newGame();

  void playAt(BoardPosition position) {
    try {
      state = state.playMove(position);
    } on InvalidMoveException {
      // Ignore invalid interactions; UI can decide to surface feedback later.
    }
  }

  void reset() {
    state = TicTacToeGame.newGame(
      startingPlayer: state.startingPlayer.opponent,
    );
  }
}

final gameControllerProvider = NotifierProvider<GameController, TicTacToeGame>(
  GameController.new,
);
```
#### presentation/features/game/controllers/matchmaking_controller.dart:
```dart
import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:not_so_tic_tac_toe_game/core/di/providers.dart';
import 'package:not_so_tic_tac_toe_game/domain/repositories/matchmaking_repository.dart';
import 'package:not_so_tic_tac_toe_game/domain/value_objects/match_join_result.dart';
import 'package:not_so_tic_tac_toe_game/presentation/features/game/controllers/remote_match_providers.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/match_state.dart';

enum MatchmakingPhase { idle, searching, connecting, matchReady, error }

class MatchmakingState {
  const MatchmakingState({
    required this.phase,
    this.assignedMatchId,
    this.errorMessage,
  });

  const MatchmakingState.idle() : this(phase: MatchmakingPhase.idle);

  const MatchmakingState.searching()
      : this(phase: MatchmakingPhase.searching);

  const MatchmakingState.connecting(String matchId)
      : this(
          phase: MatchmakingPhase.connecting,
          assignedMatchId: matchId,
        );

  final MatchmakingPhase phase;
  final String? assignedMatchId;
  final String? errorMessage;

  MatchmakingState copyWith({
    MatchmakingPhase? phase,
    Object? assignedMatchId = _sentinel,
    Object? errorMessage = _sentinel,
  }) {
    return MatchmakingState(
      phase: phase ?? this.phase,
      assignedMatchId: identical(assignedMatchId, _sentinel)
          ? this.assignedMatchId
          : assignedMatchId as String?,
      errorMessage: identical(errorMessage, _sentinel)
          ? this.errorMessage
          : errorMessage as String?,
    );
  }

  static const _sentinel = Object();
}

class MatchmakingController extends Notifier<MatchmakingState> {
  MatchmakingRepository get _repository =>
      ref.read(matchmakingRepositoryProvider);

  String get _playerId => ref.read(playerIdProvider);

  int _operationToken = 0;

  @override
  MatchmakingState build() {
    ref.listen<AsyncValue<MatchState?>>(
      activeMatchProvider,
      (_, next) {
        next.whenData((match) {
          if (match != null) {
            state = state.copyWith(
              phase: MatchmakingPhase.matchReady,
              assignedMatchId: match.id,
              errorMessage: null,
            );
          } else if (state.phase == MatchmakingPhase.matchReady) {
            state = const MatchmakingState.idle();
          }
        });
      },
    );

    ref.onDispose(() {
      if (state.phase == MatchmakingPhase.searching) {
        unawaited(_repository.leaveQueue(_playerId));
      }
    });

    return const MatchmakingState.idle();
  }

  Future<void> startSearch() async {
    if (state.phase == MatchmakingPhase.searching ||
        state.phase == MatchmakingPhase.connecting) {
      return;
    }

    final currentToken = ++_operationToken;
    state = const MatchmakingState.searching();

    try {
      final result = await _repository.joinQueue(_playerId);
      if (currentToken != _operationToken) return;

      switch (result.status) {
        case MatchJoinStatus.waiting:
          state = const MatchmakingState.searching();
          break;
        case MatchJoinStatus.matchReady:
        case MatchJoinStatus.alreadyInMatch:
          final matchId = result.matchId;
          if (matchId != null) {
            state = MatchmakingState.connecting(matchId);
          }
          break;
      }
    } catch (error) {
      if (currentToken != _operationToken) return;
      state = MatchmakingState(
        phase: MatchmakingPhase.error,
        errorMessage: error.toString(),
      );
    }
  }

  Future<void> cancelSearch() async {
    if (state.phase != MatchmakingPhase.searching) return;

    final currentToken = ++_operationToken;
    state = const MatchmakingState.idle();

    try {
      await _repository.leaveQueue(_playerId);
    } finally {
      if (currentToken == _operationToken) {
        state = const MatchmakingState.idle();
      }
    }
  }

  Future<void> leaveMatch(String matchId) async {
    final matchRepository = ref.read(matchRepositoryProvider);

    final currentToken = ++_operationToken;
    await matchRepository.leaveMatch(
      matchId: matchId,
      playerId: _playerId,
    );

    ref.invalidate(activeMatchProvider);
    if (currentToken == _operationToken) {
      state = const MatchmakingState.idle();
    }
  }

  Future<void> playAgain(String matchId) async {
    await leaveMatch(matchId);
    await startSearch();
  }
}

final matchmakingControllerProvider =
    NotifierProvider<MatchmakingController, MatchmakingState>(
  MatchmakingController.new,
);
```
#### presentation/features/game/controllers/remote_match_providers.dart:
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:not_so_tic_tac_toe_game/core/di/providers.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/match_state.dart';

final activeMatchProvider = StreamProvider<MatchState?>((ref) {
  final repository = ref.watch(matchRepositoryProvider);
  final playerId = ref.watch(playerIdProvider);
  return repository.watchActiveMatch(playerId: playerId);
});
```
#### presentation/features/player/controllers/player_profile_providers.dart:
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:not_so_tic_tac_toe_game/core/di/providers.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/player_profile.dart';
import 'package:not_so_tic_tac_toe_game/domain/repositories/player_profile_repository.dart';

final _playerProfileInitializationProvider = FutureProvider<void>((ref) async {
  final repository = ref.watch(playerProfileRepositoryProvider);
  final playerId = ref.watch(playerIdProvider);
  await repository.ensureProfileInitialized(playerId: playerId);
});

final playerProfileProvider = StreamProvider<PlayerProfile>((ref) {
  // Ensure the profile document exists before subscribing to changes.
  ref.watch(_playerProfileInitializationProvider);
  final repository = ref.watch(playerProfileRepositoryProvider);
  final playerId = ref.watch(playerIdProvider);
  return repository.watchProfile(playerId: playerId);
});
```

### Available Files in Project:
- main.dart
- data/matchmaking/firebase_matchmaking_repository.dart
- data/matchmaking/firebase_match_repository.dart
- data/modifiers/stub_modifiers.dart
- data/player/firebase_player_profile_repository.dart
- presentation/app/game_app.dart
- presentation/features/highlights/highlight_recorder.dart
- presentation/features/highlights/highlight_share_target.dart
- presentation/features/game/widgets/game_status_banner.dart
- presentation/features/game/widgets/ultimate_mode_board.dart
- presentation/features/game/widgets/modifier_category_reveal.dart
- presentation/features/game/widgets/tic_tac_toe_board.dart
- presentation/features/game/pages/game_home_page.dart
- presentation/features/game/controllers/offline_match_controller.dart
- presentation/features/game/controllers/game_controller.dart
- presentation/features/game/controllers/matchmaking_controller.dart
- presentation/features/game/controllers/match_highlight_controller.dart
- presentation/features/game/controllers/remote_match_providers.dart
- presentation/features/player/widgets/player_streak_badge.dart
- presentation/features/player/controllers/player_profile_providers.dart
- auth/auth_manager.dart
- firebase_options.dart
- core/theme/app_theme.dart
- core/di/providers.dart
- domain/modifiers/game_modifier.dart
- domain/modifiers/modifier_algorithms.dart
- domain/modifiers/modifier_category.dart
- domain/modifiers/modifier_registry.dart
- domain/value_objects/match_join_result.dart
- domain/repositories/player_profile_repository.dart
- domain/repositories/matchmaking_repository.dart
- domain/repositories/match_repository.dart
- domain/entities/game_status.dart
- domain/entities/player_profile.dart
- domain/entities/player_mark.dart
- domain/entities/ultimate_board_state.dart
- domain/entities/match_state.dart
- domain/entities/tic_tac_toe_game.dart
- domain/entities/board_position.dart
- domain/exceptions/invalid_move_exception.dart

### Package Information:
- Package name: not_so_tic_tac_toe_game

## Instructions for this specific task:
- PRIORITY: Ensure the code compiles correctly - simplicity over complexity
- Analyze the provided widget code below to identify all widgets
- For each widget, create ONE preview function with realistic default parameters
- ONLY create additional variants if the widget has different constructor parameters that produce visually different results
- DO NOT create variants for internal state, counter values, form states, or user interactions
- Copy imports EXACTLY from the reference widget file imports above, adding proper aliasing (as i0, as i1, etc.)
- If you see provider setup in the context files, copy that pattern exactly for any provider usage
- NEVER import files that are not shown in the context above
- NEVER call methods unless you are certain they exist from the provided context
- NEVER create any code outside the @Preview functions - no classes, widgets, or helper functions

## CRITICAL: Choose ONE of these two responses:

**OPTION 1: Generate the complete preview file**
- If you can create meaningful previews with the current context, respond with ONLY the raw Dart code
- If you see imports in the widget code for files you need (models, services, other widgets), REQUEST THEM
- When uncertain, either REQUEST the files you need OR choose the simpler approach that is guaranteed to compile
- Do not include any explanations, markdown, or code blocks - just the preview file content

**OPTION 2: Request additional files (RECOMMENDED when needed)**
- If you see imports or dependencies that you need to understand (like custom models, services, or widgets)
- Request files that exist in the available files list above
- Respond with: REQUEST_FILES: file1.dart, file2.dart
- This helps you create better previews with proper parameter types and realistic data

## Widget Code to Analyze:
File path: /hologram/data/workspace/project/lib/presentation/features/game/widgets/ultimate_mode_board.dart
```dart
import 'package:flutter/material.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/board_position.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/game_status.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/player_mark.dart';
import 'package:not_so_tic_tac_toe_game/domain/entities/ultimate_board_state.dart';

typedef UltimateCellSelected = void Function(BoardPosition position);
typedef UltimateCanSelectCell = bool Function(BoardPosition position);

class UltimateModeBoard extends StatelessWidget {
  const UltimateModeBoard({
    super.key,
    required this.state,
    required this.onCellSelected,
    required this.canSelectCell,
    required this.matchStatus,
    this.localPlayerMark,
    this.lastMove,
  });

  final UltimateBoardState state;
  final UltimateCellSelected onCellSelected;
  final UltimateCanSelectCell canSelectCell;
  final GameStatus matchStatus;
  final PlayerMark? localPlayerMark;
  final BoardPosition? lastMove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return LayoutBuilder(
      builder: (context, constraints) {
        return AspectRatio(
          aspectRatio: 1,
          child: Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              borderRadius: BorderRadius.circular(22),
              border: Border.all(
                color: theme.colorScheme.outline.withOpacity(0.4),
                width: 1.4,
              ),
            ),
            child: GridView.count(
              physics: const NeverScrollableScrollPhysics(),
              shrinkWrap: true,
              crossAxisCount: 3,
              mainAxisSpacing: 10,
              crossAxisSpacing: 10,
              children: List.generate(9, (index) {
                final miniBoard = state.boardAt(index);
                final isBoardActive = _isBoardActive(index, miniBoard);
                return _MiniBoard(
                  board: miniBoard,
                  boardIndex: index,
                  onCellSelected: onCellSelected,
                  canSelectCell: canSelectCell,
                  isActive: isBoardActive,
                  lastMove: lastMove,
                  matchStatus: matchStatus,
                );
              }),
            ),
          ),
        );
      },
    );
  }

  bool _isBoardActive(int index, UltimateMiniBoard board) {
    if (!board.isPlayable) return false;
    if (board.openCellIndices.isEmpty) return false;
    if (state.activeBoardIndex == null) {
      return true;
    }
    return state.activeBoardIndex == index;
  }
}

class _MiniBoard extends StatelessWidget {
  const _MiniBoard({
    required this.board,
    required this.boardIndex,
    required this.onCellSelected,
    required this.canSelectCell,
    required this.isActive,
    required this.lastMove,
    required this.matchStatus,
  });

  final UltimateMiniBoard board;
  final int boardIndex;
  final UltimateCellSelected onCellSelected;
  final UltimateCanSelectCell canSelectCell;
  final bool isActive;
  final BoardPosition? lastMove;
  final GameStatus matchStatus;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final baseColor = board.isPlayable
        ? theme.colorScheme.surface
        : theme.colorScheme.surfaceVariant.withOpacity(0.85);
    final borderColor = board.isWon
        ? theme.colorScheme.secondary
        : board.isDraw
            ? theme.colorScheme.tertiary
            : isActive
                ? theme.colorScheme.primary
                : theme.colorScheme.outlineVariant;

    return AnimatedContainer(
      duration: const Duration(milliseconds: 220),
      curve: Curves.easeOutCubic,
      decoration: BoxDecoration(
        color: baseColor,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(
          color: borderColor.withOpacity(isActive ? 0.9 : 0.6),
          width: isActive ? 2.6 : 1.6,
        ),
        boxShadow: [
          if (isActive)
            BoxShadow(
              color: borderColor.withOpacity(0.25),
              blurRadius: 14,
              spreadRadius: 1,
            ),
        ],
      ),
      child: Stack(
        children: [
          GridView.builder(
            physics: const NeverScrollableScrollPhysics(),
            shrinkWrap: true,
            padding: const EdgeInsets.all(8),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3,
              mainAxisSpacing: 6,
              crossAxisSpacing: 6,
            ),
            itemCount: 9,
            itemBuilder: (context, cellIndex) {
              final cellRow = cellIndex ~/ 3;
              final cellCol = cellIndex % 3;
              final globalRow = (boardIndex ~/ 3) * 3 + cellRow;
              final globalCol = (boardIndex % 3) * 3 + cellCol;
              final position = BoardPosition(
                row: globalRow,
                col: globalCol,
                dimension: 9,
              );
              final mark = board.cells[cellIndex];
              final selectable = canSelectCell(position) && matchStatus == GameStatus.inProgress;
              final isLastMove = lastMove != null && lastMove == position;

              return _UltimateCell(
                mark: mark,
                onTap: selectable
                    ? () => onCellSelected(position)
                    : null,
                isSelectable: selectable,
                isLastMove: isLastMove,
              );
            },
          ),
          if (board.isWon || board.isDraw)
            _ResolvedBoardOverlay(
              winner: board.winner,
              isDraw: board.isDraw,
            ),
        ],
      ),
    );
  }
}

class _UltimateCell extends StatelessWidget {
  const _UltimateCell({
    required this.mark,
    required this.onTap,
    required this.isSelectable,
    required this.isLastMove,
  });

  final PlayerMark? mark;
  final VoidCallback? onTap;
  final bool isSelectable;
  final bool isLastMove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final highlightColor = theme.colorScheme.secondaryContainer.withOpacity(0.25);
    final baseColor = mark == null
        ? (isSelectable
            ? theme.colorScheme.surface
            : theme.colorScheme.surfaceVariant.withOpacity(0.6))
        : theme.colorScheme.surfaceVariant.withOpacity(0.95);

    final borderColor = isLastMove
        ? theme.colorScheme.secondary
        : isSelectable
            ? theme.colorScheme.primary.withOpacity(0.7)
            : theme.colorScheme.outlineVariant;

    return AnimatedContainer(
      duration: const Duration(milliseconds: 160),
      decoration: BoxDecoration(
        color: baseColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: borderColor,
          width: isLastMove ? 2 : 1.3,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        splashColor: highlightColor,
        child: Center(
          child: Text(
            mark?.label ?? '',
            style: theme.textTheme.titleLarge?.copyWith(
              fontWeight: FontWeight.bold,
              color: mark == null
                  ? theme.colorScheme.primary
                  : mark == PlayerMark.x
                      ? theme.colorScheme.primary
                      : theme.colorScheme.secondary,
            ),
          ),
        ),
      ),
    );
  }
}

class _ResolvedBoardOverlay extends StatelessWidget {
  const _ResolvedBoardOverlay({
    this.winner,
    required this.isDraw,
  });

  final PlayerMark? winner;
  final bool isDraw;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = isDraw
        ? theme.colorScheme.tertiary
        : winner == PlayerMark.x
            ? theme.colorScheme.primary
            : theme.colorScheme.secondary;

    final icon = isDraw
        ? Icons.handshake_rounded
        : Icons.emoji_events_rounded;

    final label = isDraw ? 'Draw' : winner?.label ?? '';

    return Positioned.fill(
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(18),
          color: color.withOpacity(0.12),
          border: Border.all(
            color: color.withOpacity(0.4),
            width: 1.8,
          ),
        ),
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, color: color.withOpacity(0.85), size: 28),
              const SizedBox(height: 6),
              Text(
                label,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w700,
                  color: color.withOpacity(0.9),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

## Current Preview File:
```dart
import 'package:flutter/widgets.dart';
import 'package:not_so_tic_tac_toe_game/presentation/features/game/widgets/ultimate_mode_board.dart' as i0;
import 'package:flutter/foundation.dart' as i1;
import 'package:not_so_tic_tac_toe_game/domain/entities/ultimate_board_state.dart' as i2;
import 'package:not_so_tic_tac_toe_game/domain/entities/player_mark.dart' as i3;
import 'package:not_so_tic_tac_toe_game/domain/entities/game_status.dart' as i4;
import 'package:not_so_tic_tac_toe_game/domain/entities/board_position.dart' as i5;


@Preview(name: 'UltimateModeBoard')
Widget previewUltimateModeBoard() {
  return i0.UltimateModeBoard(
    key: /* TODO: provide optional Key value for key: */ i1.Key(
      /* TODO: provide String value for value: */ '',
    ),
    state: /* TODO: provide UltimateBoardState value for state: */ i2.UltimateBoardState(
      miniBoards: /* TODO: provide List value for miniBoards: */ <i2.UltimateMiniBoard>[],
      activeBoardIndex: /* TODO: provide optional int value for activeBoardIndex: */ 0,
      lastMove: /* TODO: provide optional BoardPosition value for lastMove: */ i5.BoardPosition(
        row: /* TODO: provide int value for row: */ 0,
        col: /* TODO: provide int value for col: */ 0,
        dimension: /* TODO: provide int value for dimension: */ 0,
      ),
    ),
    onCellSelected: /* TODO: provide function value for onCellSelected: */ (
      i5.BoardPosition position,
    ) {
      // TODO: implement callback
    },
    canSelectCell: /* TODO: provide function value for canSelectCell: */ (
      i5.BoardPosition position,
    ) {
      return /* TODO: provide bool for return type */ false;
    },
    matchStatus: /* TODO: provide GameStatus value for matchStatus: */ i4.GameStatus.inProgress,
    localPlayerMark: /* TODO: provide optional PlayerMark value for localPlayerMark: */ i3.PlayerMark.x,
    lastMove: /* TODO: provide optional BoardPosition value for lastMove: */ i5.BoardPosition(
      row: /* TODO: provide int value for row: */ 0,
      col: /* TODO: provide int value for col: */ 0,
      dimension: /* TODO: provide int value for dimension: */ 0,
    ),
  );
}


```

Generate the complete preview file content focusing on parameter-driven configurations only. Do not include any code blocks or markdown formatting in your response - just the raw Dart code.
#########################
ASSISTANT
#########################
import 'package:flutter/material.dart';
import 'package:not_so_tic_tac_toe_game/presentation/features/game/widgets/ultimate_mode_board.dart' as i0;
import 'package:not_so_tic_tac_toe_game/domain/entities/ultimate_board_state.dart' as i1;
import 'package:not_so_tic_tac_toe_game/domain/entities/player_mark.dart' as i2;
import 'package:not_so_tic_tac_toe_game/domain/entities/game_status.dart' as i3;
import 'package:not_so_tic_tac_toe_game/domain/entities/board_position.dart' as i4;

@Preview(name: 'UltimateModeBoard_Empty')
Widget previewUltimateModeBoardEmpty() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (_) => i1.UltimateMiniBoard(
          cells: List.filled(9, null),
          openCellIndices: List.generate(9, (index) => index),
        ),
      ),
      activeBoardIndex: null,
      lastMove: null,
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => true,
    matchStatus: i3.GameStatus.inProgress,
    localPlayerMark: i2.PlayerMark.x,
    lastMove: null,
  );
}

@Preview(name: 'UltimateModeBoard_ActiveBoard')
Widget previewUltimateModeBoardActiveBoard() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (boardIndex) => i1.UltimateMiniBoard(
          cells: List.filled(9, null),
          openCellIndices: List.generate(9, (index) => index),
        ),
      ),
      activeBoardIndex: 4, // Middle board is active
      lastMove: null,
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => true,
    matchStatus: i3.GameStatus.inProgress,
    localPlayerMark: i2.PlayerMark.o,
    lastMove: null,
  );
}

@Preview(name: 'UltimateModeBoard_WithMoves')
Widget previewUltimateModeBoardWithMoves() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (boardIndex) {
          if (boardIndex == 0) {
            return i1.UltimateMiniBoard(
              cells: [
                i2.PlayerMark.x, null, null,
                null, i2.PlayerMark.o, null,
                null, null, i2.PlayerMark.x,
              ],
              openCellIndices: [1, 2, 3, 5, 6, 7],
            );
          } else if (boardIndex == 1) {
            return i1.UltimateMiniBoard(
              cells: [
                i2.PlayerMark.o, i2.PlayerMark.o, i2.PlayerMark.o,
                null, null, null,
                null, null, null,
              ],
              openCellIndices: [3, 4, 5, 6, 7, 8],
              winner: i2.PlayerMark.o,
            );
          }
          return i1.UltimateMiniBoard(
            cells: List.filled(9, null),
            openCellIndices: List.generate(9, (index) => index),
          );
        },
      ),
      activeBoardIndex: 2,
      lastMove: i4.BoardPosition(row: 0, col: 1, dimension: 9),
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => true,
    matchStatus: i3.GameStatus.inProgress,
    localPlayerMark: i2.PlayerMark.x,
    lastMove: i4.BoardPosition(row: 0, col: 1, dimension: 9),
  );
}

@Preview(name: 'UltimateModeBoard_GameOverDraw')
Widget previewUltimateModeBoardGameOverDraw() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (boardIndex) => i1.UltimateMiniBoard(
          cells: [
            i2.PlayerMark.x, i2.PlayerMark.o, i2.PlayerMark.x,
            i2.PlayerMark.o, i2.PlayerMark.x, i2.PlayerMark.o,
            i2.PlayerMark.o, i2.PlayerMark.x, i2.PlayerMark.o,
          ],
          openCellIndices: [],
          isDraw: true,
        ),
      ),
      activeBoardIndex: null,
      lastMove: null,
      isDraw: true,
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => false,
    matchStatus: i3.GameStatus.draw,
    localPlayerMark: i2.PlayerMark.x,
    lastMove: null,
  );
}

@Preview(name: 'UltimateModeBoard_GameOverWinner')
Widget previewUltimateModeBoardGameOverWinner() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (boardIndex) {
          if (boardIndex == 0 || boardIndex == 1 || boardIndex == 2) {
            return i1.UltimateMiniBoard(
              cells: [
                i2.PlayerMark.x, i2.PlayerMark.x, i2.PlayerMark.x,
                i2.PlayerMark.o, null, null,
                i2.PlayerMark.o, null, null,
              ],
              openCellIndices: [4, 5, 7, 8],
              winner: i2.PlayerMark.x,
            );
          }
          return i1.UltimateMiniBoard(
            cells: List.filled(9, null),
            openCellIndices: List.generate(9, (index) => index),
          );
        },
      ),
      activeBoardIndex: null,
      lastMove: null,
      winner: i2.PlayerMark.x,
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => false,
    matchStatus: i3.GameStatus.won,
    localPlayerMark: i2.PlayerMark.x,
    lastMove: null,
  );
}
#########################
USER
#########################
I received these analyzer errors from the generated preview file:

{"line": 19, "column": 11, "message": "The named parameter 'openCellIndices' isn't defined."}
{"line": 43, "column": 11, "message": "The named parameter 'openCellIndices' isn't defined."}
{"line": 79, "column": 15, "message": "The named parameter 'openCellIndices' isn't defined."}
{"line": 94, "column": 15, "message": "The named parameter 'openCellIndices' isn't defined."}
{"line": 100, "column": 13, "message": "The named parameter 'openCellIndices' isn't defined."}
{"line": 141, "column": 7, "message": "The named parameter 'isDraw' isn't defined."}
{"line": 135, "column": 11, "message": "The named parameter 'openCellIndices' isn't defined."}
{"line": 136, "column": 11, "message": "The named parameter 'isDraw' isn't defined."}
{"line": 185, "column": 7, "message": "The named parameter 'winner' isn't defined."}
{"line": 173, "column": 15, "message": "The named parameter 'openCellIndices' isn't defined."}
{"line": 179, "column": 13, "message": "The named parameter 'openCellIndices' isn't defined."}
{"line": 17, "column": 16, "message": "The named parameter 'index' is required, but there's no corresponding argument."}
{"line": 17, "column": 16, "message": "The named parameter 'status' is required, but there's no corresponding argument."}
{"line": 17, "column": 16, "message": "The named parameter 'winner' is required, but there's no corresponding argument."}
{"line": 41, "column": 25, "message": "The named parameter 'index' is required, but there's no corresponding argument."}
{"line": 41, "column": 25, "message": "The named parameter 'status' is required, but there's no corresponding argument."}
{"line": 41, "column": 25, "message": "The named parameter 'winner' is required, but there's no corresponding argument."}
{"line": 67, "column": 20, "message": "The named parameter 'index' is required, but there's no corresponding argument."}
{"line": 67, "column": 20, "message": "The named parameter 'status' is required, but there's no corresponding argument."}
{"line": 67, "column": 20, "message": "The named parameter 'winner' is required, but there's no corresponding argument."}
{"line": 82, "column": 20, "message": "The named parameter 'index' is required, but there's no corresponding argument."}
{"line": 82, "column": 20, "message": "The named parameter 'status' is required, but there's no corresponding argument."}
{"line": 98, "column": 18, "message": "The named parameter 'index' is required, but there's no corresponding argument."}
{"line": 98, "column": 18, "message": "The named parameter 'status' is required, but there's no corresponding argument."}
{"line": 98, "column": 18, "message": "The named parameter 'winner' is required, but there's no corresponding argument."}
{"line": 123, "column": 25, "message": "The named parameter 'index' is required, but there's no corresponding argument."}
{"line": 123, "column": 25, "message": "The named parameter 'status' is required, but there's no corresponding argument."}
{"line": 123, "column": 25, "message": "The named parameter 'winner' is required, but there's no corresponding argument."}
{"line": 161, "column": 20, "message": "The named parameter 'index' is required, but there's no corresponding argument."}
{"line": 161, "column": 20, "message": "The named parameter 'status' is required, but there's no corresponding argument."}
{"line": 177, "column": 18, "message": "The named parameter 'index' is required, but there's no corresponding argument."}
{"line": 177, "column": 18, "message": "The named parameter 'status' is required, but there's no corresponding argument."}
{"line": 177, "column": 18, "message": "The named parameter 'winner' is required, but there's no corresponding argument."}

Please fix these errors and generate the corrected preview file. Focus on simplicity and ensure the code compiles correctly. Output only the raw Dart code.
#########################
ASSISTANT
#########################
import 'package:flutter/material.dart';
import 'package:not_so_tic_tac_toe_game/presentation/features/game/widgets/ultimate_mode_board.dart' as i0;
import 'package:not_so_tic_tac_toe_game/domain/entities/ultimate_board_state.dart' as i1;
import 'package:not_so_tic_tac_toe_game/domain/entities/player_mark.dart' as i2;
import 'package:not_so_tic_tac_toe_game/domain/entities/game_status.dart' as i3;
import 'package:not_so_tic_tac_toe_game/domain/entities/board_position.dart' as i4;

@Preview(name: 'UltimateModeBoard_Empty')
Widget previewUltimateModeBoardEmpty() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (index) => i1.UltimateMiniBoard(
          index: index,
          cells: List.filled(9, null),
          status: i3.GameStatus.inProgress,
          winner: null,
        ),
      ),
      activeBoardIndex: null,
      lastMove: null,
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => true,
    matchStatus: i3.GameStatus.inProgress,
    localPlayerMark: i2.PlayerMark.x,
    lastMove: null,
  );
}

@Preview(name: 'UltimateModeBoard_ActiveBoard')
Widget previewUltimateModeBoardActiveBoard() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (index) => i1.UltimateMiniBoard(
          index: index,
          cells: List.filled(9, null),
          status: i3.GameStatus.inProgress,
          winner: null,
        ),
      ),
      activeBoardIndex: 4, // Middle board is active
      lastMove: null,
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => true,
    matchStatus: i3.GameStatus.inProgress,
    localPlayerMark: i2.PlayerMark.o,
    lastMove: null,
  );
}

@Preview(name: 'UltimateModeBoard_WithMoves')
Widget previewUltimateModeBoardWithMoves() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (boardIndex) {
          if (boardIndex == 0) {
            return i1.UltimateMiniBoard(
              index: boardIndex,
              cells: [
                i2.PlayerMark.x, null, null,
                null, i2.PlayerMark.o, null,
                null, null, i2.PlayerMark.x,
              ],
              status: i3.GameStatus.inProgress,
              winner: null,
            );
          } else if (boardIndex == 1) {
            return i1.UltimateMiniBoard(
              index: boardIndex,
              cells: [
                i2.PlayerMark.o, i2.PlayerMark.o, i2.PlayerMark.o,
                null, null, null,
                null, null, null,
              ],
              status: i3.GameStatus.won,
              winner: i2.PlayerMark.o,
            );
          }
          return i1.UltimateMiniBoard(
            index: boardIndex,
            cells: List.filled(9, null),
            status: i3.GameStatus.inProgress,
            winner: null,
          );
        },
      ),
      activeBoardIndex: 2,
      lastMove: i4.BoardPosition(row: 0, col: 1, dimension: 9),
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => true,
    matchStatus: i3.GameStatus.inProgress,
    localPlayerMark: i2.PlayerMark.x,
    lastMove: i4.BoardPosition(row: 0, col: 1, dimension: 9),
  );
}

@Preview(name: 'UltimateModeBoard_GameOverDraw')
Widget previewUltimateModeBoardGameOverDraw() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (index) => i1.UltimateMiniBoard(
          index: index,
          cells: [
            i2.PlayerMark.x, i2.PlayerMark.o, i2.PlayerMark.x,
            i2.PlayerMark.o, i2.PlayerMark.x, i2.PlayerMark.o,
            i2.PlayerMark.o, i2.PlayerMark.x, i2.PlayerMark.o,
          ],
          status: i3.GameStatus.draw,
          winner: null,
        ),
      ),
      activeBoardIndex: null,
      lastMove: null,
      winner: null, // UltimateBoardState doesn't have isDraw, use winner: null for draw
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => false,
    matchStatus: i3.GameStatus.draw,
    localPlayerMark: i2.PlayerMark.x,
    lastMove: null,
  );
}

@Preview(name: 'UltimateModeBoard_GameOverWinner')
Widget previewUltimateModeBoardGameOverWinner() {
  return i0.UltimateModeBoard(
    state: i1.UltimateBoardState(
      miniBoards: List.generate(
        9,
        (boardIndex) {
          if (boardIndex == 0 || boardIndex == 1 || boardIndex == 2) {
            return i1.UltimateMiniBoard(
              index: boardIndex,
              cells: [
                i2.PlayerMark.x, i2.PlayerMark.x, i2.PlayerMark.x,
                i2.PlayerMark.o, null, null,
                i2.PlayerMark.o, null, null,
              ],
              status: i3.GameStatus.won,
              winner: i2.PlayerMark.x,
            );
          }
          return i1.UltimateMiniBoard(
            index: boardIndex,
            cells: List.filled(9, null),
            status: i3.GameStatus.inProgress,
            winner: null,
          );
        },
      ),
      activeBoardIndex: null,
      lastMove: null,
      winner: i2.PlayerMark.x,
    ),
    onCellSelected: (position) {
      print('Cell selected: $position');
    },
    canSelectCell: (position) => false,
    matchStatus: i3.GameStatus.won,
    localPlayerMark: i2.PlayerMark.x,
    lastMove: null,
  );
}
